# 自动推荐

推荐座位流程说明

由于票档和分区是多对多关系

用户进入抢票页面，系统会让用户选择票档，之后从该票档的所有分区推荐最优座位，分两步走
1. 推荐该票档的最高优先级分区 
2. 推荐该分区的最优座位

**推荐分区**：因为所有的分区都做唯一优先级排序，因此寻找比较简单，但需要注意如果优先级相同，
推荐请求要均匀路由到各个分区里，避免严重数据倾斜情况，即订单全落到A分区，而同等优先级的B分区没有订单

**推荐选座**：推荐选座相对复杂，需要保证唯一性防止重复推荐和少卖。
因为秒杀场景下，有 100 个线程并发进来请求推荐座位，如果设计不合理，就会出现推荐一个座位，
只有一个请求成功，剩下99个都失败的极端场景。因此要保证一个座位只会推荐给其他用户

> 如果像是传统数字库存，还可以用分段锁，将 100 个库存分成几段，让并发的请求落在不同的段上分别来抢库存，这样能分摊大量的流量，失败的几率降低。
> 
> 但这种方案对于自动推荐其实并不适用，因为用户请求过来是要求系统为其分配座位的，如果用户收到提示推荐失败只会认为系统有问题，因此这就是分段锁不适用的原因

## 设计难点

- **推荐座位唯一性（一票一座）**

在高并发场景下怎么解决用户推荐重复座位的问题呢？即秒杀场景下100个用户系统并发推荐相同的座位（因为是并发）

可以选择 MQ 异步或者直接单线程模型使并发请求串行化，这样就能保证并发线程请求都成功且推荐合理座位

- **座位存储结构设计（如何存储座位优先级）**

每次都需要给用户推荐最佳座位，按照优先级从高到低排序、连坐场景

连坐的话比较简单，每个座位信息还需要存储左右关系。

优先级需要实现的操作是：添加座位库存（取消、重新推荐）会按照优先级重新排序，弹出座位库存（预占）会弹出优先级最高的库存座位，
可以考虑用树或者堆来做。

实现方案：

自动选座这两个难点，可以用 redis 来做

- redis 天生单线程可以保证用户推荐座位的唯一性
- 采用 redis 的 zset 结构来存储座位图信息，每次推荐 N 个座位就执行 ZMPOP 操作，释放预占就执行 ZADD 操作，score 存储优先级 

> ZADD 的时间复杂度是 O(N)，N 是排序集合中元素的数量 
> 
> ZMPOP 的时间复杂度是：O(K)+O(M*log(N))，其中 K 是提供的键的数量，N 是排序集合中的元素数量，M 是弹出的元素数量

ZMPOP 语法：`ZMPOP numkeys key [key ...] <MIN | MAX> [COUNT count]` ，numkeys 表示有多少个 zset 参与弹出操作，
    min/max 意味着弹出小数据还是大数据，count 表示弹出的数量（大于zset规模则弹出集合所有元素）

ZMPOP 会按参数中指定的 key 顺序依次检查，‌从第一个非空的有序集合中弹出元素‌，并终止命令‌。 

当多个有序集合存在优先级关系时（如不同业务队列），可通过调整 key 顺序实现优先处理高优先级集合的成员。

正好适合当前在线座位库存自动推荐场景：多个有序集合（分区优先级，座位优先级）

因此我们设置两个有序集合，分区优先级有序集合以及座位优先级有序集合

### 稳定性方面：
每个用户购连坐票时，如果系统主流程推荐没有推荐出足够的票数，都会额外锁定很多连续区域，虽然后面会释放掉碎片占用，但会不会有问题？

比如释放不及时，其他用户抢不到票？又比如一直占用(释放失败怎么办)，导致少卖？

## 模块功能流程阐述：

### 推荐并锁座

1. 判断当前用户是否持有用户锁（redis set 是否有记录）-> redis 要保证高可用，redis 宕机服务进不去
2. 推荐座位并锁座，轮训分区数量进行推荐操作
   1. 每次推荐都会从 redis 查询一下当前最新的各分区具体票数， 
      1. 如果说有某个分区的票数充足（但不保证座位连续）并从中筛选出最高优先级的分区返回； 
      2. 否则就是说明各个分区的票都不能满足购买，但加起来可以，会返回多个分区（跨分区）
      3. 当然售罄或票数不足会直接返回空数组
   2. 该分区不止一个，走多分区推荐模式，流程是轮询从每个分区 pop 出剩余的票，此时是补偿流程，不保证连坐，没有连坐时会有 UI 提示
   3. 该分区只有一个，才是正常的流程
      1. 先走主流程逻辑，从分区库存队列里中尝试 popM，M 表示用户购票数量，pop出来检查是否连坐，
      这里如果 pop 出来连 M 都没有，说明库存已经不足了，直接不推荐了
      
      2. 如果不连坐，就会走碎片化流程:
         - 先尝试 popN（实为 popM，检查 N），N 表示至少要往后补几张才能凑成连坐，根据当前 M 从后往前有多少个连续来算的
            - 从中寻找能组成连坐的部分（两种情况，M1+M2 两者连坐 或 M2 自身连坐，因为 M1 可能在一排尾部，M2 在另一排头部）
            - 其中 M1 表示主流程 popM 的实际数量，M2 表示碎片化流程 popM 的实际数量
         - 还是不连坐就释放掉 M2，尝试 query2M 查询是否有连坐（查询到连坐需要使用 remove 释放而不是 pop，因为有可能连坐不在 Set 头部）
      3. 碎片化流程后得到连坐，则释放掉主流程里没被用到的库存；不连坐则释放掉碎片化流程申请的库存
      4. 申请座位批量加分布式锁 setNx，key："pre_seat_lock"（sort防死锁，这里加锁是避免补偿逻辑出现多个用户 pop 出同一个座位的异常场景）
      5. 用户申请座位批量加分布式锁 setNx, key: "user_recommend_seats"
3. 写用户锁座记录，sadd（这里不持久化？？？）

## 缓存结构

票档：show_of_project_ticket

|  | 说明 | 示例       |
|---|----|----------|
| key | 场次id，show_id | 11       |
| value | 票档列表 list | 11,22,33 |

分区：area_of_project_ticket

|  | 说明       | 示例            |
|---|----------|---------------|
| key | 票档id     | 11            |
| value | 票档下的分区列表<br/>分区信息：ID，名称，优先级，排序规则 | |

```json
[
    {
        "areaId":1,
        "name":"分区1",
        "partitionlevel":1,
        "seatAllocationRule":1
    },
    {
        "areaId":2,
        "name":"分区2",
        "partitionlevel":1,
        "seatAllocationRule":1
    },
    {
        "areaId":3,
        "name":"分区3",
        "partitionlevel":2,
        "seatAllocationRule":2
    }
]
```

座位列表缓存：seat_bucket

|       | 说明               | 示例    |
|-------|------------------|-------|
| key   | 票档id_分区id        | 11_11 |
| value | 1. 采用ZSet的结构进行存储<br/>2. set中为座位列表<br/>3. score计算：<br/>座位优先级从左向右：Y * 100000 + X<br/>座位优先级从右向右：Y * 100000 - X<br/>4 座位信息如下：  |       |



