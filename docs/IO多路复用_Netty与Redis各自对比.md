# 前言

想要对比两个框架，从根本上来说，就是分析两个框架是为了解决什么问题而诞生的，为了解决什么用户痛点，才选择了 IO 多路复用。

即：先理解问题，再理解设计

这个分析过程，需要查书找资料问AI，最终总结出两个框架的同异

我将把内容转换为一个清晰的对比表格：

| 对比项 | Netty | Redis                                                                              |
|--------|--------|------------------------------------------------------------------------------------|
| 使用场景 | 帮助程序员实现各种不可预知的业务需求 | 以服务端形式存在，支持redis本身定义的命令（如setNx, lpush等）                                            |
| 核心痛点 | 自身的阻塞问题：<br>- 业务需求不可预知<br>- 实现代码很可能出现阻塞<br>- 如调用第三方接口、操作数据库等 | 向客户端返回数据时的问题：<br>- 返回大量数据时可能影响性能<br>- 客户端响应慢会间接影响redis性能（单线程）<br>- 滑动窗口可能"阻塞"redis |
| 业务特点 | 业务需求不可预知 | 业务需求确定，基于内存，基本不会阻塞                                                                 |


## Netty

Netty 主要是需要解决进行网络IO时的阻塞问题，为此他引入了三个线程组：bossGroup、workerGroup、bizGroup

1. bossGroup: 该线程组的线程驱动的 epoll，是专门用于处理 listen_sock 上的事件，避免不可控的业务代码影响到新建连接
2. workerGroup: 该线程组的线程各自驱动 epoll，用于处理不同 client_sock 上的事件
3. bizGroup: 直接将可能阻塞的业务代码做异步处理，避免影响到 epoll 循环

简单来说就是采用：多 epoll + 业务逻辑异步处理的思路

## Redis

Redis 主要是需要解决大体积数据包传输给客户端时的阻塞问题，为此引入了IO线程将这一过程非阻塞

简单来说就是采用：单 epoll + 业务逻辑单线程 + IO 线程辅助读写数据



